<<T Task Creation>>
<<H1 Task Creation>>
<<HR>>
Two routines, <<X NewTask>> and <<X NewKernelTask>>, in the file <<F newtask.c>> handle the creation of tasks. <<X NewKernelTask>> creates a task running as part of the kernel, with the appropriate privileges. <<X NewTask>> creates a user task and is slightly more complicated as it loads the code from disk - I'll describe the operation of this routine and hope the differences in the kernel version are obvious.
<<PAR>>
The first thing that <<X NewTask>> does is to open the file containing the task code. Next interrupts are suspended; we don't want anything to interfere whilst we are creating the task. The stack pointer is set to point to a temporary stack which is filled with values which would be expected after an interrupt has been called (the new process will actually be activated by a task switch which is activated by an interrupt, so we must simulate that situation for the new task). The <<C waiting>> field of the task structure is set to 0 to indicate that the task is ready to run. A new Page Directory is created for the task by the call to <<X VCreatePageDir>> and this is stored in the <<C cr3>> field; also the <<X ds>> field is set.
<<PAR>>
Having filled in these necessary fields in the task structure (the remainder, except for <<C firstfreemem>>, which will be set shortly, are unimportant at the moment; these will be filled in next time the task is switched from - they will be important then) we can now proceed to read the code from the disk file with a series of <<X ReadFile>> calls. The first of these calls merely skips past a 4-character header; I really ought to check this to ensure that this is a valid program file. Next the lengths of the code and data are read, and then the code and data themselves are read into temporary buffers. (Actually, these buffers aren't really temporary; <<X VCreatePageDir>> set these memory addresses to point to the physical memory allocated to the code and data pages of the task itself. This can be a little difficult to grasp at first. Basically the task's memory map and the kernel's memory map are pointing to the same two buffers; to the task they are the code and data addresses for the task, to the kernel they are just temporary buffers. This allows the kernel to easily write to the task's memory space, always using the same location for any task.)
<<PAR>>
Now the task has a task structure, a memory map, and code and data. The only thing left to do is to set the field <<C firstfreemem>> in the task structure, and to link the task structure into the linked list of task structures by a call to <<X LinkTask>>. Now we re-enable interrupts and the task is ready to take it's turn at the next task switch. (You can appreciate why we didn't want any interrupts - and hence, potentially, task switches - whilst we were setting the task up. It wouldn't have been pretty if the task were activated whilst it was still being set up!)
<<PAR>>
As well as creating tasks we want to be able to terminate them; this is accomplished by the function <<X KillTask>> in <<F newtask.c>>, which kills the current task. This is fairly straightforward - first the task is removed from the linked list of runnable tasks, and then the physical memory that has been allocated to the task is released.
<<HR>>
<<CONT>>
