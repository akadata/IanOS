<<T Keyboard>>
<<H1 Keyboard>>
<<CONT>>
<<HR>>
The keyboard driver is about the simplest device driver there can be (at least conceptually). It consists of two parts, the interrupt routine and the keyboard processing code; this latter runs as a separate task and communicates with other programs by receiving and sending messages.
<<PAR>>
The interrupt routine is <<X KbInt>> in the file <<F interrupts.s>> It reads the code from the keyboard port and saves it in the array <<C kbBuffer>>; also the variables <<C kbBufCount>> (the number of keystrokes currently in the buffer) and <<C kbBufCurrent>> (the next free space in the buffer) are incremented. If necessary <<C kbBufCurrent>> wraps around to the start of the buffer. Next a check of the blocked tasks list is made to see if any task is waiting for keyboard input; if so the task is reawakened by setting its <<C waiting>> flag to 0. The interrupt is then re-enabled to await the next keystroke.
<<PAR>>
The real work of the keyboard routine is done in the keyboard task <<X kbTaskCode>>, which is defined in the file <<F keyboard.c>>. Messages to and from the keyboard task are sent via the port <<C KbdPort>> (this is defined in <<F cmemory.h>> as a fixed position in memory - other tasks have to know where to find it). The very first thing that is done in this task is to enable the keyboard interrupt; this was disabled until now as we don't want keyboard interrupts happening until we are ready to handle them. The rest of the keyboard task is an infinite loop which waits for a message on <<C KbdPort>> requesting a service; the service requested is encoded in the <<C byte>> field of the messages struct. Currently the only service provided is a request for a character; further services may be provided in future. (For example, it might be useful to provide a "peek" service, which returned information about whether a keystroke was available without actually returning the keystroke.) First <<C kbBufCount>> is checked to see if a keystroke is available; if not the task blocks waiting for an interrupt to re-awaken it. The keystroke is then read from <<C kbBuffer>> and manipulated to obtain the corresponding character or, if it is a modifier, to set appropriate flags. The code for this should be fairly self-explanatory. Finally a message is constructed and sent back to the requesting program. This is sent on a temporary port that was created by the calling program - it's address was passed to the keyboard task in the <<C tempPort>> element of the message struct. (We can't use <<C KbdPort>> to send the return message ona as it might have messages from other programs queued; if we used it as the return port we would, erroneously, receive the first of these messages)
<<PAR>>
<<HR>>
<<CONT>>
