<<NAVSTART>>
	<<PREV display.html Display>>
	<<CONT>>
	<<NEXT ide.html Hard Disk>>
<<NAVEND>>
<<T Keyboard>>
<<H1 Keyboard>>
<<HR>>
The keyboard driver is about the simplest device driver there can be (at least conceptually). It consists of two parts, the interrupt routine and the keyboard processing code; this latter runs as a separate task and communicates with other programs by receiving and sending messages.
<<PAR>>
The interrupt routine is <<X KbInt>> in the file <<F interrupts.s>> It reads the code from the keyboard port and saves it in the array <<C kbBuffer>>; also the variables <<C kbBufCount>> (the number of keystrokes currently in the buffer) and <<C kbBufCurrent>> (the next free space in the buffer) are incremented. If necessary <<C kbBufCurrent>> wraps around to the start of the buffer. A message is then sent to the keyboard task to tell it that a keypress is waiting to be processed. The interrupt is then re-enabled to await the next keystroke.
<<PAR>>
The real work of the keyboard routine is done in the keyboard task <<X kbTaskCode>>, which is defined in the file <<F keyboard.c>>. Messages to and from the keyboard task are sent via the port <<C KbdPort>> (this is defined in <<F include/memory.h>> as a fixed position in memory - other tasks have to know where to find it). The very first thing that is done in this task is to enable the keyboard interrupt; this was disabled until now as we don't want keyboard interrupts happening until we are ready to handle them. The rest of the keyboard task is an infinite loop which waits for a message on <<C KbdPort>> requesting a service; the service requested is encoded in the <<C byte>> field of the messages struct. 
<<PAR>>
The task provides three services: <<C GETCHAR>>, <<C GETKEY>>, and <<C KEYPRESSED>>. <<C KEYPRESSED>> is used only by the keyboard interrupt routine via the function <<X keyPressed>>. It takes the character from the keyboard queue and either does something with it directly or else puts it on the input queue of the appropriate console. I don't seem to actually use <<C GETKEY>> at the moment. (Perhaps it is a hangover from the previous version.) I must check more closely to see if it is needed. The message that is used by user programs is <<C GETCHAR>>; you can guess what it does.
<<PAR>>
<<X GetChar>> simply extracts the waiting character (if there is one) from the appropriate console keyboard buffer and then calls <<X ProcessMsgQueue>> to create a message to send back to the requesting program. This is sent on a temporary port that was created by the calling program - its address was passed to the keyboard task in the <<C tempPort>> element of the message struct. (We can't use <<C KbdPort>> to send the return message on as it might have messages from other programs queued; if we used it as the return port we would, erroneously, receive the first of these messages.)
<<PAR>>
<b>Note:</b> The keyboard task code has become rather more complicated since I introduced multiple consoles, and I'm aware that I haven't explained it very well. I'll try to improve this documentation in the future.
<<HR>>
<<NAVSTART>>
	<<PREV display.html Display>>
	<<CONT>>
	<<NEXT ide.html Hard Disk>>
<<NAVEND>>