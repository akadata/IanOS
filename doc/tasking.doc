<<T Tasking>>
<<H1 Tasking>>
<<CONT>>
<<HR>>
To actually achieve anything the OS runs a number of tasks. Some of these are user programs, others are central to the OS itself; for example, hardware drivers, such as those for the keyboard or the display, run as separate tasks. One of the prime functions of an OS is to manage these separate tasks; each must be activated at regular intervals to give the impression that they are all running all of the time. In 32-bit (Protected) mode the x86 processors actually provide hardware support for task switching. In practice most operating systems do not make use of this hardware support; this is so that their code is portable to other processors. In any case, in 64-bit mode the processor does not provide this hardware support, so it all has to be done in software.
<<PAR>>
Information about tasks is stored in the structure <<X Task>> as defined in the file <<F ckstructs.h>> (an assembly code version of this structure is also defined in <<F kstructs.h>>). This structure consists of a pointer to the next task structure (so that we can create a linked list of structures, a flag to determine whether the task is waiting for something else to happen (e.g. an interrupt), fields for the processor registers, some fields to record the location of some items, and a pid (Processor Identifier Descriptor) so that we can tell which process is which. The task structure is always accessed via register <<C r15>>; this makes the assembler code easier. You must ensure that the address of the appropriate task structure is in <<C r15>> before accessing the fields of the structure. Each time a task switch occurs (i.e. the task is activated or deactivated) various of these fields - in particular the processor registers - need to be read or updated.
<<PAR>>
Task switches can be called by a program when it wants to wait for some event. Otherwise they will occur at regular intervals, triggered by the timer interrupt, thus ensuring that all processes get a fair share of processor time. (This is an extremely simplistic method of scheduling processes; one of the major feature of a real OS is to manage the processor time that processes get equably. There are many algorithms to accomplish this.)
<<PAR>>
There are two routines, defined in <<F tasking.s>> to accomplish a task switch. <<X TaskSwitch>> switches to the next available task, <<X SpecificTaskSwitch>> switches to the task specified in register <<C r15>>. This is used, for example, in the hard disk interrupt routine; we want to switch to the task that called for hard disk input as soon as it is available. The only difference between the two routines is that the non-specific switch first searches through the linked list of tasks to find the next one that is ready to run. If there is no other runnable task it checks to see if the current task is still runnable; if not it halts the processor and waits for an interrupt. Both routines then save the contents of the registers to the task structure and retrieve those of the new task. As one of the registers saved and restored is the stack pointer, the final <<C ret>> instruction returns not to the code that called the task switch but to the code that caused a task switch from the task being switched to. (If that doesn't seem clear, think about it. We don't want to return to the code that called the task switch - and as the memory map has been changed by restoring <<C cr3>> it might not even make sense to do so - but to the point that the new task was at before it last relinquished the processor.) 
<<PAR>>
There are a couple of things about saving/restoring registers that needs to be explained further. First, one has to be a little careful about <<C r15>>. When the routine is called <<C r15>> points to the task to switch to, which is what we want to save, but we change it to point to the current task (so that we can access its task structure). Hence the "<<C push %r15>>" instruction before <<C currentTask>> is stored in <<C r15>>; this pushed value is later popped to <<C rax>> and then stored to the task structure. Second, these two routines are designed to be called as subroutines from within an interrupt routine (<<X SwitchTasks>> and <<X SpecificSwitchTasks>>). If we just saved the stack pointer we would just be saving the address of the calling interrupt routine; what we really want to save is stack pointer when the interrupt routine called the subroutine. This is why there is a "<<C pop %rcx>>" before saving the stack pointer and a "<<C push %rcx>>" after restoring it.
<<HR>>
<<CONT>>

