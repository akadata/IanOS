<<T SysCalls>>
<<H1 System Calls>>
<<HR>>
Due to the protection mechanisms built into the processor, programs running with user privilege cannot access certain memory locations, or execute certain instructions. This, after all, is the whole point of the protection mechanisms - to protect the kernel against errant user programs. Some mechanism has to be found to let a user program indicate to the kernel that it requires certain tasks to be undertaken on its behalf. The easiest way to accomplish this (although not the only way) is to use the <<C syscall>> and <<C sysret>> instructions. These instructions allow the program to switch privilege levels, run some kernel code, and then switch back again. In reality most programs will request many kernel services by sending a message to a kernel task - but message sending itself requires a system call.
<<PAR>>
All system calls are defined in <<F syscalls.s>> (although most of the routines here call functions from elsewhere in the kernel). The <<C syscall>> instruction always jumps to the same code (in our case <<X SysCalls>>) with register <<C r9>> containing the number of the particular system call requested. A simple jump table routes to the appropriate routine. These routines are all very simple, and must all end with a <<C sysret>> instruction to return to the calling program. The current selection is by no means complete; in a more complete system there will be a lot more of them (and some of the current ones will, no doubt, disappear.)
<<HR>>
<<CONT>>
